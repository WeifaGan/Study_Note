# 第一章 计算机系统漫游

## 1.1 信息就是位+上下文

* 系统上的所有信息都是一系列的0和1组成位，每8位就会组成一组，称为字节。也可以说所以的信息都是由字节序列组成。
* 同一个字节序列表示的信息都是一样的吗？也不是！**同样的字节序列可以表示为整数、浮点数、字符串或者机器指令**。所以说系统上的信息由位组成也不完全正确，还要加上上下文，不同的上下文有不同的意思。所以，**信息就是位+上下文**。

## 1.2 程序被其他程序翻译成不同的格式

你写的程序计算机并读不懂，所以计算机需要对你的程序转化位自己看得懂的。在Linux上，从源文件到目标文件的转化都是由**编译器驱动程序**完成。整个翻译构成一个编译系统，过程包括：

* 预处理阶段：把#开头的命令替换成本身的内容。此时得到的是一个hello.i文件。
* 编译阶段：**编译器**将.i文件翻译成**汇编语言程序**，得到hello.s的文件。
* 汇编阶段：**汇编器**将.s文件翻译成机器指令，得到hello.o文件。
* 链接阶段：某些调用的程序会被单独地放在预编译的目标文件中，这些文件会被合并到.o文件中，最后得到hello文件(可执行文件，可执行文件会经常听过，其实它就是整个编译完成后得到的文件)，可以加载到内存被系统执行。

## 1.3 了解编译系统如何工作大有益处

* 优化程序性能
* 链接链接时出现的错误
* 避免安全漏洞

## 1.4 处理器读并解释存储在内存中的指令

翻译好的hello可执行文件放在磁盘中，如果想要运行该程序，将它的文件名输入到shell即可。shell会加载并运行该程序。

### 1.4.1系统的硬件组成

要理解程序执行时候发生的一切，就先了解系统的硬件把。

* 总线：系统硬件各个部分的信息的传输交给了总线，它运输信息的单位称为**字**。在32位和64位系统中，字长分别是4个和8个字节。所以说64位的系统的信息传输速度会更快。总线包括系统总线、内存总线和I/O总线。
* I/O设备：鼠标键盘显示器磁盘
* 主存(内存，由一组DRAM芯片组成)：用于存放程序和程序处理的数据。机器指令的字节数不一定相同，在linux上，short要2个字节，int和float要4个自己，long和double字节要8个字节。
* 处理器：负责执行内存中的指令。CPU的核心是一个大小为一个**字**的寄存器(**程序计算器PC**)。CPU会不断地执行PC指向地指令，然后更新PC，使其指向下一条指令(不一定是相邻地指令)。

### 1.4.2 运行hello程序

* 第一步，让CPU知道你要干嘛：在键盘中输入“./hello”字符，shell将字符逐一读入寄存器，在放到内存(字符进入内存之前还要经过CPU寄存器)
* 第二步，执行前的准备：回车后，shell加载可执行地hello文件，将代码数据从磁盘复制到内存(利用DMA技术，这一步数据可以不经过CPU，要复制什么内容到内容，还是CPU说了算，所以上一步要把文件名字符读入寄存器)
* 第三步，开始执行了：hello文件中代码和数据加载到内存后，CPU开始执行hello程序中的机器指令。
* 第四步，显示：运行的结果“helloword”会被从内存复制到寄存器文件(由一些单个字长的寄存器组成)，再从寄存器文件复制到显示设备。

## 1.5 高速缓存至关重要

* 小的存储设备比大的存储设备要快，快的存储设备比同类低速的设备造价高。
* 加快处理器运行速度比加快内存运行速度要更加容易和便宜。
* 高速缓存存储器相当于暂时的中间站，用来存放CPU最近可能需要处理的信息，这样子读取更快，有些信息不用到内存中读取了。

## 1.6 存储设备形成层次结构

* 存储器层次结构的主要思想是上一层的存储器作为低 一层存储器的高级缓存。

## 1.7 操作系统管理硬件

* 所以应用程序对硬件的操作尝试都必须通过操作系统
* 操作系统两个基本功能：
  * 防止硬件被失控的应用程序滥用
  * 向应用程序提供机制来控制硬件设备
* 操作系统通过进程(处理器主存IO设备抽象表示)、虚拟内存(主存和IO设备的抽象表示)和文件(IO设备的抽象表示)来完成上述两个功能

### 1.7.1 进程

* 进程是对正在运行程序的抽象，它让我们以为程序一条接着一条不间断地执行。
* 并发运行说的是一个进程的指令和另外一个进程的指令是交错执行的，也就是说系统不会把一个进程执行完之后再执行另外一个进程。
* 单处理器系统某一个时刻只能执行一个进程，那如果要处理多个进程怎么办？那就要进行上下文(跟踪进程所需要的信息)切换了。
* 进程间的转换由操作系统的内核管理。内核其实是管理全部进程所用到的代码和数据结构的集合。

### 1.7.2 线程

* 一个进程可以由多个线程单元组成。
* 每个线程都运行在进程的上下文中，并共享同样的代码和数据。

### 1.7.3 虚拟内存

* 进程骗了我们，虚拟内存也会骗进程，让每一个进程以为自己都在独占使用主存，进程看到的主存都一样的，称为虚拟地址空间。
* 进程看到的虚拟地址空间由大量的区构成，包括了程序代码和数据、堆、共享库、栈、内核虚拟内存。

### 1.7.4 文件

* 文件就是字节序列，仅仅而已
* 每个IO设备包括磁盘、键盘、显示器、甚至网络都可以看成是文件。系统所有输入输出都是通过调用读写文件来实现的。

## 1.8 系统之间利用网络通信

* 网络也是一种IO设备

## 1.9 重要主题

### 1.9.1 Amdahl定律

* 当我们对系统的某个部分加速时，其对系统整体性能的影响取决于该部分的重要性和加速程度。加速比为$S=\frac{1}{(1-a)+a/k}$

## 1.9.2 并发和并行

* 并发：通用概念，至一个同时具有多个活动的系统
* 并行：指的是通过并发来时一个系统运行得更快。
* 线程级并发
  * 这种并发是通过进程间的切换来实现的。
  * 多核处理器时将多个CPU集成到一个芯片上。
    * 减少了在执行多个任务时模拟并发的需要
    * 使得应用程度运行得更快
  * 超线程是运行一个CPU执行多个控制流的技术，例如Intel Core I7处理器每个核可以执行两个线程。
  * 超线程处理器可以在单个周期的基础上决定要执行哪一个线程。使得CPU更好地利用资源。
* 指令级并行：同时处理多条指令
* 单指令、多数据并行：允许一条指令产生多个并行执行的操作。

### 1.9 计算机系统中抽象的重要性

* 再添加一个抽象，虚拟机是整个计算机的抽象，包括操作系统、处理器和程序。

# 第3章 程序的机器级表示

能够阅读和理解汇编代码还是比较重要的技能，阅读汇编代码可以理解编译器的优化能力，并分析代码中隐含的低效率。其实优化编译器能够重新排列执行顺序，消除不必要的计算，用快速操作替慢速操作。

## 3.2程序编码

### 3.2.1 机器级代码

* 对于机器级的代码两种抽象比较重要：
  * 指令集架构(ISA)：定义机器级程序的格式和行为，包括处理器状态、指令格式以及每条指令对状态的影响。
  * 机器级程序使用的内存地址是虚拟地址
* x86-64的机器代码可以看到一些C看不到的状态:
  * 程序计数器下一条指令在内存的地址
  * 整数寄存器文件包含16个命名位置，分别存储64位的值。
  * 条件码寄存器保存这最近执行的算术或逻辑指令的状态信息

### 3.2.2 代码实例

* 查看机器码，可以使用反汇编器。
* 关于机器码和它的反汇编表示的特性值需要注意：
  * x86-64的指令长度从1到15不等。
  * 设计指令格式的方式是，从某个给定的位置开始，可以将字节唯一解码成机器指令。
  * 反汇编器只是基于机器代码文件中字节序列来确定汇编代码

 ## 3.3 数据格式

* 理解C语言数据类型在x86-64中的大小

## 3.4 访问信息

一个x86-64的CPU包含16个存储64位值的通用目的寄存器，用来存储整数数据和指针。栈指针较为特别用来指明运行时结束的位置。

### 3.4.1 操作指示符

* 熟悉操作数格式

## 3.4.2 数据传送指令

* move的四条指令：movb、movw、movl和movq，他们的操作的数据大小分别是1，2，4，8个字节。
* 目的操作数要么是寄存器要么是内存地址。
* x86-64的传送指令的两个操作数不能都指向内存位置
* 注意movq指令和movabsq指令的区别

### 3.4.3 数据传送示例

* 局部变量通常是保持在寄存器

### 3.4.4 压入和弹出栈数据

* pushq 将一个四字压人栈中，首先栈指针减8，然后将值写到新的地址
* popq 将四字弹出，栈指针加8

## 3.5 算术和逻辑操作

* 操作：加载有效地址，一元操作，二元操作和移位

### 3.5.1 加载有效地址

* 将有效地址写入目的操作数L

### 3.5.2 一元和二元操作

* 第一个操作可以是立即数，寄存器和内存位置，第二个操作数可以是寄存器或者内存位置。当第二个操作数是内存地址时候，处理器必须从内存读取值，执行操作，再把结果写回内存

### 3.5.3 移位操作

* 移位量可以是立即数，或者放在单字节寄存器%c1中，只能是%c1寄存器
* 两个左移指令都一样，右移指令不同，SAR执行算术移位(填上符号位)，SHL执行逻辑移位(填上0)

## 3.6 控制

### 3.6.1 条件码

* CPU还维护这一组单个位的条件寄存器
* 常用条件码
  * CF：进位标志
  * ZF：零标志
  * SF：符号标志
  * OF：溢出标志
* 比较和测试指令，不修改任何寄存器的值，只设置条件码

### 3.6.2 访问条件码

* 条件码使用：
  * 可以根据条件码的某种组合
  * 可以条件跳转到程序的其他的部分
  * 可以有条件地传送数据
* SET指令

# 第5章 优化程序性能

编写高效的程序需要做到以下几点：

* 我们必须选择一组是适当的算法和数据结构
* 我们编写出编译器能够有效优化以转换成高效可执行代码的源代码
* 针对运算量特别大的计算，将一个任务分成多个部分，这些部分可以在多核和多处理器的某种组合并发地计算

程序优化：

* 消除不必要的工作，包括不必要的函数调用条件测试内存引用等。
* 利用处理器提供的指令并行能力，同时执行多条指令。

另外，程序员必须理解这些处理器如何工作，从而调用他们的程序以获得最大的速度。研究程序的编译代码表示是理解编译器以及产生的代码如何运行的最有效手段之一。

## 5.1 优化编译器的能力和局限性

* 大多数编译器，包括GCC，向用户提供了一些对他们呢所使用的优化的控制，就是说大多数编译器有优化程序的能力
* **内存别名使用**是指两个指针可能指向同一内存位置
* 在只执行安全的优化中，编译器必须假设不同的指针可能会指向内存中的同一个位置，这会限制了可能的优化策略。

## 5.2 表示程序性能

* 引入度量标准每元素的周期数CPE，作为一种程序性能并知道我们改进代码的方法。帮助我们理解迭代程序的循环性能。
* 处理器活动的顺序由时钟控制的，时钟提供了某个频率的规律信号，通常用GHZ表示。

## 5.3 程序示例

* 经过-O1优化的CPE值更小。

##  5.4 消除循环的低效率

* 代码移动

## 5.5 减少过程的调用

## 5.6 消除不必要的内存引用

* 减少内存读写

## 5.7 理解现代处理器

两种下界描述了程序的最大性能：

* 延迟界限：下一条指令开始之前，这条指令必须结束
* 吞吐量界限：处理器功能单元的原始计算能力

### 5.7.1 整体操作

* 指令执行单元：从内存中读取指令序列，并生成针对程序数据的基本操作
* 执行单元：执行指令执行单元的生成的操作
* 乱序处理器框图

### 5.7.2 功能单元的性能

* 延迟：表示完成运算所需要的总时间
* 发射时间：表示两个连续的同类型的运算之间需要的最小时钟周期数
  * 流水线
  * 完全流水线化：每个时钟周期可以开始一个新的运算
  * 发射时间最常见的表示方法是功能单元的最大吞吐量，定义为发射时间的倒数
* 容量：表示能够执行该运算的功能单元的数量
* 算术运算的延迟、发射时间和容量会影响合并函数的性能

### 5.7.3 处理器操作的抽象模型

* 从机器级代码到数据流图：数据相关如何主宰程序性能
* 其他性能因素：可用单元的数量和任何一步中功能单元之间能够传递数据值的数量

## 5.8 循环展开

* 循环展开是一种程序变换，通过增加每次迭代计算的元素的数量，减少循环的迭代次数
* 循环展开从两个方面改变性能
  * 减少了不直接有助于程序结果的操作的数量
  * 减少整个计算中关键路径上的操作数量
* 很多编译器用等级3或者更高级调用GCC，它就会执行循环展开 

## 5.9 提高并行性

### 5.9.1 多个累积变量

* 先算偶数累积，再算奇数累积，再合并能够能搞性能，这是充分利用功能单元的流水线能力，将利用率提高到2倍。

### 5.9.2 重新结合变换 

* 通过改变结合的顺序来提高性能

# 第八章 异常控制流

* 从一个地址到另外一个地址的过度称为控制转移
* 控制转移序列叫做控制流
* 现代系统通过使控制流发生突变对系统状态变化做出反应，这些突变称为异常控制流(ECF)。
* 异常控制流发生发生在计算机各个层次，在硬件层，在操作系统层，在应用层。
  * 在硬件层，检测到时间然后会转移到异常处理程序
  * 在操作系统中，内核通过上下文切换从一个进程到另外一个进程
  * 应用程序中，一个进程发送信号给另外一个进程，接收者会控制突然转移到它的一个信号处理程序
* 了解ECF的原因
  * **帮助理解很多重要的系统概念**:ECF是操作系统用来实现IO、进程和虚拟内存的基本机制。
  * **帮助理解应用程序时如何与操作系统交换**
  * **理解并发**
  * **理解软件异常如何工作**

## 8.1 异常

* 异常一部分由硬件实现，一部分由操作系统实现，
  * 那编程里里面的跳转应该不是异常，因为没有硬件的实现
* 异常思想是：事件发生时，会跳转到相应的异常处理程序，然后返回当前指令或者下一条指令或者结束被终端的程序。

### 8.1.1 异常的处理

* 当检测到事件并确定相应的异常号，根据异常号来跳转到相应的处理程序。
* 硬件触发异常会怎么样？没看懂

### 8.1.2 异常的类别

* 中断
* 陷阱和系统调用
* 故障
* 终止

## 8.2 进程

* 系统中的每个程序都运行在某个进程的上下文中。上下文是由程序正确运行所需要的状态组成，包括代码数据，栈，寄存器内容、程序计数器、环境变量等。感觉就是一种资源呀。
* 每次用户向shell中输入可执行目标文件的名字时候，shell会创建一个新的进程，该进程在上下文中执行。
* 关注两个关键抽象
  * 逻辑控制流：提供程序好像独占用处理器的假象(为什么要提供这个假象)
  * 地址空间：提供程序好像独占地使用内存系统。

### 8.2.1 逻辑控制流

* 几个进程之间的切换产生一系列地PC值序列叫做逻辑控制流

### 8.2.2 并发流

* 一个逻辑流在执行时间上与另一个流重叠，称为并发流。
* 一个进程和其他进程轮流运行称为多任务。搞完一个才能搞下一个，所以任务很多。。。
* 两个流并发地运行在不同地处理器核或者计算机上，称为并发流。感觉并发指时间上由重叠，并行是指不同的处理器并发运行。

### 8.2.3 私有地址空间

* 在n位的地址空间上，地址空间的集合有2^n个
* 进程为每个程序提供了私有地址空间，因为不能被其他进程读写，所以某种程度是私有的。

### 8.2.4 用户模式核内核模式

*  处理器提高一种机制，限制一个应用可以执行的命令以及可以访问的地址空间范围
* 当设置了位模式，进程就可以在内核模式中运行，可以执行所有的指令。这里应该是一开始就运行在内核模式了。
* 没设置位模式，进程只能运行在用户模式，不允许执行特权指令。就是说内核模型具有很高的权限，而用户模式没有

* 进程从用户模式变成内核模式的唯一方法是通过异常。

### 8.2.5 上下文切换

* 内核抢占当前进程，重新开始之前被抢占了的进程，叫做调度。
* 上下文切换
  * 保存当前的是上下文
  * 恢复先前被抢占的进程被保存的上下文
  * 控制传递给这个新恢复的进程

### 8.4 进程控制

### 8.4.1 获取进程ID

* 每个进程都有唯一的整数进程ID
* getpid函数得到嗲用进程PID,getppid函数返回他的父进程的PID

### 8.4.2 创建核终止进程

* 进程总是处于下面三种状态
  * 运行
  * 停止
    * 进程的执行被挂起
  * 终止
    * 收到终止信号
    * 从主程序返回
    * 调用exit函数
* 父进程通过调用fork函数来新的运行子程序
  * 调用一次，返回两次，一次是返回到父进程，一次是返回到子进程
  * 并发执行。
  * 相同但是独立的地址空间。父子进程对变量的任何改变都是独立的。
  * 共享文件

### 8.4.3 回收子进程

* 终止的进程，并不是立刻被系统清除，而是保持一种已终止的状态，直到被它的父进程回收。
* 终止但还没会回收的进程成为僵死进程。不过它没运行，但也消耗资源。
* 一个进程可以通过调用waitpid函数来等待他的子进程终止或停止。

### 8.4.4 让进程休眠

* sleep函数让进程挂起，时间到返回0，否则返回剩下的要休眠的秒数，

### 8.4.5 加载并运行程序

* execve函数在当前进程中加载并运行程序

## 8.5 信号

* 信号是通知**进程**发生了什么事情。

### 8.5.1 信号术语

* 发送信号：内核去更新上下文的状态来发送信号的
  * 内核检测到信号事件
  * 一个进程调用了kill函数
* 接受信号：被内核逼着取处理信号

### 8.5.2 发送信号

* 进程组
  * 每个进程只属于一个进程组。
  * getpgrp返回进程组ID
  * 父子进程属于同一个进程组
  * 一个进程组可以通过setpgid来改变自己或者其他进程组ID

* 用/bin/kill程序发送信号
  * /bin/kill程序可以向另外的进程发送任意的信号
* 从键盘发送信号
  * ctrl+c 终止前台昨夜
  * ctrl+z 挂起前台作业
* 用kill函数发送信号
  * 发送信号给其他进程
* 用alarm函数发送信号
  * 向自己发送信号

### 8.5.3 接收信号

* 每个信号可能是以下几种
  * 进程终止
  * 进程终止并转储内存
  * 进程挂起直到被SIGCONT信号重启
  * 进程忽略信号
* 进程使用signal函数修改信号的默认行为

* 信号处理程序可以被其他信号处理程序终端

### 8.5.4 阻塞和解除阻塞信号

* 隐式阻塞机制：内核默认阻塞待处理信号。
* 显式阻塞机制：使用sigprocmask函数和它的辅助函数。

### 8.5.5 编写信号处理程序

* 信号处理程序很难推理分析原因：
  * 处理程序与主程序并发运行，共享同样地全局变量，可能与主程序相互干扰
  * 何时接收信号很违人地直觉
  * 不同的系统又不同信号处理语义
* 安全的信号处理
  *  0 处理程序要尽可能简单
  * 1 在处理程序中只调用异步信号安全的函数：要么可重入，要么不能被信号处理程序中断
  * 2 保存和恢复errno
  * 3 阻塞所有的信号，保护对共享全局数据结构的访问
  * 4 用volatile 声明全局变量
  * 5 用sig_atomic_t声明标志
* 正确的信号处理
* **这部分很难懂，看了感觉用不上，先放着吧。。**

# 第12章 并发编程

* 现代系统提供了三种基本的构造并发程序的方法：
  * 进程
  * I/O多路复用
  * 线程

## 12.1 基于进程的并发编程

* 构造并发程序最简单的方法是用进程，如fork，exec和waitpid等函数
* 进程的优劣
  * 优点：进程有独立的地址空间,一个进程不可能覆盖另外一个进程的虚拟地址
  * 劣点：
    * 进程比较慢，因为进程控制和进程间通信开销很高

## 12.2 基于I/O多路复用的并发编程

* 基本思想是使用select函数，要求内核挂起进程，只有在一个或者多个I/O事件发生后，才将控制返回给应用程序

## 12.3 基于线程的并发编程

* 第一种方法基于进程的编程使得进程间难以共享数据，第二种方法创建自己的逻辑流并利用IO复用技术显式调用流。基于线程并发编程时两种方法的混合。
* 基于线程的逻辑流结合进程和IO多路复用的流的特征。和进程一样，线程由内核调度，并且内核通过一个整数ID来识别线程。同基于IO多路复用的流一样，多个线程运行在单一进程的上下文，可以共享进程的所有内容。

### 12.3.1 线程执行模型

* 进程产生就会由一个主线程，不知道啥时候开始创建了对等线程，然后两线程就通过上下文切换并发执行了。
* 线程的上下文切换比进程快，要小。
* 一个进程间的线程是对等的且独立于其他线程的。
* 一个线程可以杀死了它的任何对等线程，或者等待它的任何对等线程终止

### 12.3.3 创建线程

* 线程通过调用ptheread_create函数来创建线程

### 12.3.4 终止线程

* 一个线程通过以下方式终止
  * 当顶层的线程例程返回时，线程会隐式地终止
  * 通过调用pthread_exit函数，线程会显式地终止。
  * 某个对等线程调用exit函数，该函数终止进程以及所以于该进程相关地线程(把大家都杀了)
  * 另一个对等线程通过以当前线程ID作为参数调用pthread_cancel函数来终止当前线程(被别人杀了)

### 12.3.5 回收已终止线程的资源

* 线程通过调用pthread_join函数等待其他线程终止。 

### 12.3.6 分离线程

* 在任何一个时间点上，线程时可结合的或者时分离的。
* 一个可结合的线程能够被线程收回和杀死。
* 一个分离的线程时不能被其他线程回收或杀死的。它的内存资源在它终止时系统自动释放

### 12.3.7 初始化线程

* pthread_once函数允许你初始化于线程历程相关的状态。

## 12.4 多线程程序中得共享变量

### 12.4.1 线程内存模型

* 每个线程都有自己的独立的线程上下文，每个线程和其他线程一起共享进程上下文的剩余部分。也即是说都有自己的房间也有共享的客厅
* 寄存器是从不共享的，而虚拟内存总是共享的。

### 12.4.2 将变量映射到内存

多线程的变量根据他们的存储类型被映射到虚拟内存

* 全局变量
* 本地自动变量
* 本地静态变量

### 12.4.3 共享变量

* 不是说全局的变量就是共享的，而是被多个线程引用。

## 12.5 用信号量同步线程 

* 共享变量十分方便，但是线程会引入同步错误。

* 一般而言，你没有办法预测操作系统是否将为你的线程选择一个正确的顺序。

### 12.5.1 进度图

* 进度图是将n个并发线程的执行模型化为一条n维的笛卡尔空间的轨迹图
* 不安全区
* 安全轨迹线 不安全轨迹线

### 12.5.2 信号量

* ED提供了一种解决同步不同执行线程问题的方法(什么意思)，该方法基于信号量的特殊类型变量的。
* 信号量只能由P和V操作，确保正在运行的程序不可能由信号量为负的状态

### 12.5.3 使用信号量来实现互斥

* 信号量使得对共享变量确保互斥访问。基本思想是将每个共享变量与一个信号量s联系起来，然后用PV操作将临界区包围起来
* 保护共享变量的信号只有0或者1，叫做二元信号量。
* 提供互斥为目的的二元信号量称为互斥锁。
* 在互斥锁上执行P操作称为互斥锁加锁。执行V操作称为对互斥锁解锁。
* 对一个互斥锁加了锁但是还没有解锁的线程称为占用这个互斥锁

### 12.5.4 利用信号量来调度共享资源

* 生产正-消费者问题
  * 两者对缓冲区的访问是互斥的
  * 缓冲区是满的，生产者必须等待
  * 缓冲区是空的，消费者必须等待
* 读者写者问题
  * 负责修改线程的叫写着
  * 负责只读对象的线程叫读者
  * 变种
    * 读者优先
    * 写者优先

